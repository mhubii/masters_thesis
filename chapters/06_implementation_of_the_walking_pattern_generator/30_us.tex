
\FloatBarrier
\section{Usage}
\label{sec::63_us}
The pattern generation library is built upon the fast linear algebra library Eigen \cite{eigenweb}, which makes it perfectly compatible with the rigid body dynamics library RBDL \cite{felis2017rbdl} that is used for the kinematics. Its main duty is to build the formulation of the optimal control problem that was introduced with much detail in section \ref{sec::22_nmpc}. Starting from the linear time-stepping scheme (equations \ref{eq::223_ckp1}-\ref{eq::223_ddckp1}), the \inlinecode{C++}{BaseGenerator} class sets up all of the necessary matrices for the nonlinear model predictive control. What the \inlinecode{C++}{NMPCGenerator} class then mainly does is to inherit from \inlinecode{C++}{BaseGenerator} in order to sort the matrices for the sequential quadratic programming formulation of equation \ref{eq::226_ocp}. All of the ordering is then being done by \inlinecode{C++}{NMPCGenerator::CalculateCommonExpressions}, while \inlinecode{C++}{NMPCGenerator::CalculateDerivatives} computes the linearization of the optimal control problem, which got explained in detail in section \ref{sec::226_gn}. Then to solve the sequential quadratic programming task, the pattern generation library utilizes qpOASES \cite{ferreau2014qpoases}, and the results are being interpolated by the \inlinecode{C++}{Interpolation} class, which relies on the theory of section \ref{sec::23_it}. However, to use the pattern generation library, the user does not have to deal with the private methods and can only use the public interface. A typical use case would involve the initialization of a \inlinecode{C++}{NMPCGenerator} object like so
\begin{minted}{cpp}
  // Initialize pattern generator.
  const std::string config_file_loc = "/path/to/configs.yaml";
  NMPCGenerator nmpc(config_file_loc);
\end{minted} 
where the YAML configurations file loads the robot specific settings at run time, that is they can be changed without having to recompile the code. An example of the pattern generator's configurations file is shown in figure \ref{sec::63_us_conf}. One then one must set the initial values as follows
\begin{minted}{cpp}
  // Pattern generator preparation.
  nmpc.SetSecurityMargin(nmpc.SecurityMarginX(), 
                         nmpc.SecurityMarginY());
	
  // Set initial values.
  PatternGeneratorState pg_state = {nmpc.Ckx0(),
                                    nmpc.Cky0(),
                                    nmpc.Hcom(),
                                    nmpc.Fkx0(),
                                    nmpc.Fky0(),
                                    nmpc.Fkq0(),
                                    nmpc.CurrentSupport().foot,
                                    nmpc.Ckq0()};

  nmpc.SetInitialValues(pg_state);
\end{minted}
The interpolation is then done based on the pattern generator's state, and therefore it takes a reference to it as follows
\begin{minted}{cpp}
  Interpolation ip_nmpc(nmpc);
  ip_nmpc.StoreTrajectories(true);
\end{minted}
which brings us to the main loop
\begin{minted}{cpp}
  Eigen::Vector3d velocity_reference(0.1, 0., 0.);

  // Pattern generator event loop.
  for (int i = 0; i < 100; i++) {
      std::cout << "Iteration: " << i << std::endl;

      // Set reference velocities.
      nmpc.SetVelocityReference(velocity_reference);

      // Solve QP.
      nmpc.Solve();
      nmpc.Simulate();
      ip_nmpc.InterpolateStep();

      // Initial value embedding by internal states and simulation.
      pg_state = nmpc.Update();
      nmpc.SetInitialValues(pg_state);
  }
\end{minted}
These are the main methods a user would want to interact with. \inlinecode{C++}{Simulate()} computes the states on the preview horizon for the optimization, according to equations \ref{eq::223_ckp1}-\ref{eq::223_ddckp1}, given the current state, which is then being updated by \inlinecode{C++}{Update()}. It is possible to elaborate feedback by changing the CoM, and, or the feet members of the \inlinecode{}{PatternGeneratorState} struct. Afterwards, the trajectories can be stored with
\begin{minted}{cpp}
  // Save interpolated results.
  Eigen::MatrixXd trajectories = ip_nmpc.GetTrajectories().transpose();
  WriteCsv("trajectories.csv", trajectories);
\end{minted}
The trajectories, which are being written out with this method, are ordered according to $c_k^x$, $\dot{c}_k^x$, $\ddot{c}_k^x$, $c_k^y$, $\dot{c}_k^y$, $\ddot{c}_k^y$, $c_z$, $c_k^\theta$, $\dot{c}_k^\theta$, $\ddot{c}_k^\theta$, $z_k^x$, $_k^y$, $z_k^z$, $f_k^{L,x}$, $f_k^{L,y}$, $f_k^{L,z}$, $f_k^{L,\theta}$, $f_k^{R,x}$, $f_k^{R,y}$, $f_k^{R,z}$, $f_k^{R,\theta}$. An exemplary plotting routine in python is provided at the following \href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/plot/plot_pattern.py#L15}{\underline{link}}.
\\
\begin{minipage}[t]{1.\textwidth}
	\begin{minipage}{0.5\textwidth}
		\scriptsize{
			\hfill \textbf{Specifications}\\
			\mbox{}~\hfill Double + single support time\\
			\mbox{}~\hfill Used to shrink convex hull $\bm{p}_i$ in fig.  \ref{fig::225_foot_hull}, \ref{fig::62_support_polygon}\\
			\mbox{}~\hfill The convex hull $\bm{p}^L_i$ in fig. \ref{fig::225_foot_feasibility}\\
			\mbox{}~\hfill The convex hull $\bm{p}^R_i$ in fig. \ref{fig::225_foot_feasibility}\\
			\mbox{}~\hfill Used to compute convex hull $\bm{p}_i$ in fig.  \ref{fig::225_foot_hull}, \ref{fig::62_support_polygon}\\
			\mbox{}~\hfill Used to compute convex hull $\bm{p}_i$ in fig.  \ref{fig::225_foot_hull}, \ref{fig::62_support_polygon}\\
			\mbox{}~\hfill Distance between feet frames\\
			
			\hfill \textbf{Interpolation}\\
			\mbox{}~\hfill Evaluate eq. \ref{eq::231_pos_poly}-\ref{eq::231_acc_poly} at $t=nt_\text{command\_period}$\\
			\mbox{}~\hfill Initially stand still for $n_\text{still}$ preview horizons\\
			\mbox{}~\hfill Double support time\\
			\mbox{}~\hfill Maximal step height $z_{T/2}$ in eq. \ref{eq::231_step}\\
			
			\hfill \textbf{Initial Values}\\
			\mbox{}~\hfill Initial x-CoM $\bm{c}_k^x$ in eq. \ref{eq::223_ckp1}-\ref{eq::223_ddckp1}\\
			\mbox{}~\hfill Initial y-CoM $\bm{c}_k^y$ in eq. \ref{eq::223_ckp1}-\ref{eq::223_ddckp1}\\
			\mbox{}~\hfill Initial z-CoM $c_z$ in eq. \ref{eq::223_zmp}\\
			\mbox{}~\hfill Initial $\theta$-CoM $\bm{c}_k^\theta$ in eq. \ref{eq::223_ckp1}-\ref{eq::223_ddckp1}\\
			\mbox{}~\hfill Initial support foot\\
			\mbox{}~\hfill Initial support foot $f_k^x$ in eq. \ref{eq::224_feet}\\
			\mbox{}~\hfill Initial support foot $f_k^y$ in eq. \ref{eq::224_feet}\\
			\mbox{}~\hfill Initial support foot $\bm{f}_k^\theta$ in eq. \ref{eq::223_ckp1}-\ref{eq::223_ddckp1}\\
			
			\hfill \textbf{Environment}\\
			\mbox{}~\hfill Gravity in eq. \ref{eq::223_zmp}\\
			
			\hfill \textbf{Obstacle}\\
			\mbox{}~\hfill False if no obstacle is used\\
			\mbox{}~\hfill Obstacle position $x_0$ in eq. \ref{eq::225_obstacle}\\
			\mbox{}~\hfill Obstacle position $y_0$ in eq. \ref{eq::225_obstacle}\\
			\mbox{}~\hfill Obstacle radius $R$ in eq. \ref{eq::225_obstacle}\\
			
			\hfill \textbf{Optimization}\\
			\mbox{}~\hfill Preview intervals $N$ in eq. \ref{eq::223_preview}\\
			\mbox{}~\hfill Preview time $T$ in eq. \ref{eq::223_preview_mat}\\
			\mbox{}~\hfill CoM and feet position feedback time\\
			\mbox{}~\hfill Weight in eq. \ref{eq::224_dcxy}-\ref{eq::224_dddcxy}\\
			\mbox{}~\hfill Weight in eq. \ref{eq::224_dcxy}-\ref{eq::224_dddcxy}\\
			\mbox{}~\hfill Weight in eq. \ref{eq::224_dcxy}-\ref{eq::224_dddcxy}\\
			\mbox{}~\hfill Maximally allowed CPU time for qpOASES\\
			\mbox{}~\hfill Maximally allowed number of calculations for qpOASES}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
		\begin{lstlisting}[language=yaml]
# Specifications.
t_step: 3.2
security_margin: [0.02, 0.02]
left_foot_convex_hull: [-0.11, 0.14, ...]
right_foot_convex_hull: [-0.11, -0.14, ...]
foot_width: 0.1
foot_length: 0.2
foot_distance: 0.14

# Interpolation.
command_period: 0.01
n_still: 0
t_ds: 1.6
step_height: 0.03

# Initial values.
com_x: [0.0 , 0.0, 0.0]
com_y: [0.05, 0.0, 0.0]
com_z: 0.45
com_q: [0.0 , 0.0, 0.0]
support_foot: left
foot_x: 0.0
foot_y: 0.07
foot_q: 0.0

# Environment.
gravity: 9.81

# Obstacle.
obstacle: false
x_pos:  10
y_pos:  10
radius: 0.5

# Optimization.
n: 16
t: 0.4
t_feedback: 0.4
alpha: 1
beta: 1e2
gamma: 1e-2
cpu_time: 0.1
nwsr: 1000
		\end{lstlisting}
	\end{minipage}
	\label{sec::63_us_conf}
	\captionof{table}{The configurations YAML file for the pattern generator, and its relation to the background of section \ref{sec::2_bg}. It can be found at the provided \href{https://github.com/mhubii/nmpc_pattern_generator/blob/master/libs/pattern_generator/configs.yaml}{\underline{link}}.}
\end{minipage}
\\
\\
To run the code on a real robot, one must use inverse kinematics, which turn the obtained CoM, and feet positions, into joint angles $\bm{q}$. Within this work, this is done with RBDL, and implemented in the \inlinecode{C++}{Kinematics} class, which also provides methods to generate feedback via forward kinematics. It is therefore required to initialize a \inlinecode{}{Kinematics} object as follows
\begin{minted}{cpp}
  // Kinematics.
  const std::string config_file_loc = "/path/to/configs.yaml";
  Kinematics ki(config_file_loc);
\end{minted}
which loads the configurations from a YAML file that can be found in figure \ref{sec::63_ki_conf}. One of the most important settings in there is the location of the robot's URDF model. For Heicub, this model is located in the models folder from figure \ref{fig::62_folder}.  It is then required to initialize the inverse kinematics with an appropriate guess, such that it does not converge to an unwanted local minimum. We can do so by setting the initial joint angles with
\begin{minted}{cpp}
  // Initialize position with a good guess.
  Eigen::VectorXd q_init(21 /*heicub's degrees of freedom*/);
  q_init.setZero();

  q_init = ...;

  ki.SetQInit(q_init);
\end{minted}
and finally compute the desired joint angles by
\begin{minted}{cpp}
  // Get the desired initial state of the robot.
  Eigen::MatrixXd traj = ip_nmpc.GetTrajectories();

  // Initialize inverse kinematics.
  Eigen::MatrixXd com_traj(4, traj.cols());     
  Eigen::MatrixXd lf_traj(4, traj.cols());  
  Eigen::MatrixXd rf_traj(4, traj.cols());

  ki.Inverse(com_traj, lf_traj, rf_traj);
  Eigen::MatrixXd q_traj = ki.GetQTraj();
\end{minted}
How to use these joint angles, in order to get it running on Heicub, is described in section \ref{sec::8_co}. We have now seen that it is only required to set the reference velocity to control the robot, and the next section will explain how this can be done with the use of a neural network.
\\
\begin{minipage}[t]{1.\textwidth}
	\hspace*{-1cm}
	\begin{minipage}{0.4\textwidth}
		\scriptsize{
			\hfill \textbf{URDF Model}\\
			\mbox{}~\hfill URDF model for kinematics with RBDL\\
			
			\hfill \textbf{Initial Inverse Kinematic Runs}\\
			\mbox{}~\hfill Run inverse kinematics initially $n_\text{init}$ times\\
			
			\hfill \textbf{Inverse Kinematic Parameters}\\
			\mbox{}~\hfill Tolerance used for convergence detection\\
			\mbox{}~\hfill Damping $\lambda$ in eq. \ref{eq::242_levenberg}\\
			\mbox{}~\hfill Maximally allowed optimization steps\\
			
			\hfill \textbf{Body Points}\\
			\mbox{}~\hfill Computed automatically by RBDL\\
			\mbox{}~\hfill Left foot inverse kinematics constraint\\
			\mbox{}~\hfill Right foot inverse kinematics constraint}
	\end{minipage}
	\begin{minipage}{0.6\textwidth}
		\begin{lstlisting}[language=yaml]
# Location of the urdf model.
urdf_loc: ../../models/icub_heidelberg01_no_weights.urdf

# Number of pre-initializations for inverse kinematics.
n_init: 10

# Parameters for the inverse kinematics.
step_tol: 1e-12
lambda: 1e-2
num_steps: 1000

# Body points.
com_body_point: [0.0, 0.0, 0.0]
lf_body_point: [0.0, 0.0, 0.0]
rf_body_point: [0.0, 0.0, 0.0]
		\end{lstlisting}
	\end{minipage}
	\label{sec::63_ki_conf}
	\captionof{table}{The configurations YAML file for the kinematics, and its relation to the background of section \ref{sec::2_bg}. It can be found at the provided \href{https://github.com/mhubii/nmpc_pattern_generator/blob/master/libs/kinematics/configs.yaml}{\underline{link}}.}
\end{minipage}






