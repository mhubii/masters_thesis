\FloatBarrier
\section{Implementation Details}
\label{sec::62_id}
The pattern generator, which got conceptually explained in the previous section, and which is shown in figure \ref{fig::61_pg}, consists of mainly four building blocks. That is, the forward kinematics, the nonlinear model predictive control, the interpolation, and the inverse kinematics. All of these building blocks got written from scratch within the presented work, but all of them rely on already existing software. While the nonlinear model predictive control, as well as the interpolation, were implemented as separated classes in C++, the inverse, and the forward kinematics were integrated into a single kinematics class. All of the classes are part of the libs folder, which is shown in figure \ref{fig::62_folder}. By design, the project also holds models, among them Heicub's universal robot description file (URDF) model for computing the kinematics with RBDL, and another one for pure visualization with MeshUp \cite{meshup}. Other folders are the sh folder, which contains shell scripts for easy execution, and furthermore the source folder, which relies on the libraries to build executables from. While these executables are very much dependent on the robot at hand, as they are coupled to the robot's communication system, which will be explained in section \ref{sec::8_co}, they pose some nice examples on how the pattern generator can be embedded into a robot's operating system.
\begin{figure}[h!]
	\begin{forest}
		for tree={
			font=\ttfamily,
			grow'=0,
			child anchor=west,
			parent anchor=south,
			anchor=west,
			calign=first,
			edge path={
				\noexpand\path [draw, \forestoption{edge}]
				(!u.south west) +(7.5pt,0) |- node[fill,inner sep=1.25pt] {} (.child anchor)\forestoption{edge label};
			},
			before typesetting nodes={
				if n=1
				{insert before={[,phantom]}}
				{}
			},
			fit=band,
			before computing xy={l=15pt},
		}
		[\href{https://github.com/mhubii/nmpc_pattern_generator}{\underline{nmpc\_pattern\_generator}}
		[\href{https://github.com/mhubii/nmpc_pattern_generator/tree/master/libs}{\underline{libs}}
		[\href{https://github.com/mhubii/nmpc_pattern_generator/tree/master/libs/kinematics}{\underline{kinematics}}[\href{https://github.com/mhubii/nmpc_pattern_generator/tree/master/libs/kinematics/include/kinematics}{\underline{include/kinematics}}[kinematics.h]][configs.yaml]
		]
		[\href{https://github.com/mhubii/nmpc_pattern_generator/tree/master/libs/pattern_generator}{\underline{pattern\_generator}}[\href{https://github.com/mhubii/nmpc_pattern_generator/tree/master/libs/pattern_generator/include/pattern_generator}{\underline{include/pattern\_generator}}[base\_generator.h][interpolation.h][nmpc\_generator.h]]
		[configs.yaml]]
		]
		[\href{https://github.com/mhubii/nmpc_pattern_generator/tree/master/models}{\underline{models}}]
		[\href{https://github.com/mhubii/nmpc_pattern_generator/tree/master/sh}{\underline{sh}}]
		[\href{https://github.com/mhubii/nmpc_pattern_generator/tree/master/src}{\underline{src}}]
		]
	\end{forest}
	\caption{Folder structure of the code, which got implemented for this thesis. The code is freely available on GitHub at the provided \href{https://github.com/mhubii/nmpc_pattern_generator}{\underline{link}}. Install instruction can be found in the appendix \ref{sec::A_si}.}
	\label{fig::62_folder}
\end{figure}

\FloatBarrier
\subsection{Nonlinear Model Predictive Control Class}
The kinematics class utilizes the rigid body dynamics library \cite{felis2017rbdl}, which in turn is based upon the linear algebra library Eigen \cite{eigenweb}. Therefore, Eigen was used for the formulation of the nonlinear model predictive control, as well as for the interpolation class. The formulation itself is implemented within the \inlinecode{}{NMPCGenerator} class, which relies on qpOASES \cite{ferreau2014qpoases} to solve the sequential quadratic problem. All of the required matrices that is the constant, as well as the varying matrices for the linear time-stepping scheme, the varying foot selection matrices, and the constraint matrices, are initialized, and constantly being updated in the \inlinecode{}{BaseGenerator} class, from which the \inlinecode{}{NMPCGenerator} class inherits. The most important methods of each class, as well as their correspondence to the theory of section \ref{sec::2_hw}, are shown in figure \ref{fig::62_nmpc_generator}.
\begin{figure}
	\centering
	\begin{tikzpicture}[node distance=2cm]
	\node (base_generator) [abstract, rectangle split, rectangle split parts=1]
	{
		\textbf{BaseGenerator}
	};
	\node (base_generator_methods) [comment, rectangle split, rectangle split parts=3, below=0.2cm of base_generator, text justified]
	{
		\textbf{Methods}
		\nodepart{second}\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/base_generator.cpp#L225}{SetSecurityMargin} \ref{fig::225_foot_hull}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/base_generator.cpp#L325}{SetVelocityReference} \ref{eq::224_dcxy}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/base_generator.cpp#L945}{Simulate} \ref{eq::223_ckp1} - \ref{eq::223_ddckp1}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/base_generator.cpp#L252}{SetInitialValues} \ref{eq::223_ckp1} - \ref{eq::223_ddckp1}
		\nodepart{third}\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/base_generator.cpp#L478}{InitializeConstantMatrices} \ref{eq::223_pos_mat} - \ref{eq::223_acc_mat}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/5a213044c927dc6aac9f7e32ce1e5fb472cd67bb/libs/pattern_generator/src/base_generator.cpp#L420}{InitializeCopMatrices} \ref{sec::223_zmp_s_mat}-\ref{sec::223_zmp_u_mat}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/base_generator.cpp#L798}{UpdateSelectionMatrices} \ref{eq::224_fs}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/base_generator.cpp#L1339}{UpdateFootSelectionMatrices} \ref{eq::224_fsm}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/base_generator.cpp#L902}{ComputeLinearSystem} \ref{fig::225_foot_hull}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/5a213044c927dc6aac9f7e32ce1e5fb472cd67bb/libs/pattern_generator/src/base_generator.cpp#L946}{BuildCopConstraint} \ref{eq::22_cop_hull}\\\href{https://github.com/mhubii/nmpc_pattern_generator/blob/5a213044c927dc6aac9f7e32ce1e5fb472cd67bb/libs/pattern_generator/src/base_generator.cpp#L1004}{BuildFootIneqConstraint} \ref{eq::225_ineq_foot}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/5a213044c927dc6aac9f7e32ce1e5fb472cd67bb/libs/pattern_generator/src/base_generator.cpp#L1187}{BuildRotIneqConstraint} \ref{eq::225_ineq_rot}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/5a213044c927dc6aac9f7e32ce1e5fb472cd67bb/libs/pattern_generator/src/base_generator.cpp#L1214}{BuildObstacleConstraint} \ref{eq::225_obs_const}
	};
	\node (nmpc_generator) [abstract, rectangle split, rectangle split parts=1, below=8cm of base_generator]
	{
		\textbf{NMPCGenerator}
	};
	\node (nmpc_generator_methods) [comment, rectangle split, rectangle split parts=3, below=0.2cm of nmpc_generator, text justified]
	{
		\textbf{Methods}
		\nodepart{second}\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/nmpc_generator.cpp#L65}{Solve}
		\nodepart{third}\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/nmpc_generator.cpp#L155}{PreProcessSolution} \ref{eq::226_ocp} - \ref{eq::226_lin}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/nmpc_generator.cpp#L668}{SolveQP}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/nmpc_generator.cpp#L700}{PostProcessSolution} \ref{sec::226_update}
	};
	
	\draw[line] (nmpc_generator.west) -- ++ (0,0) -- ([yshift=0cm, xshift=-0.2cm] nmpc_generator.west) -- ([yshift=0cm, xshift=-0.2cm] base_generator.west) -- (base_generator.west) -- ++(0,0) ;
	\end{tikzpicture}
	\caption{The \inlinecode{}{NMPCGenerator} class inherits from the \inlinecode{}{BaseGenerator} class, which initializes, and updates the matrices that are used for the formulation of the sequential quadratic problem. Important methods, and their correspondence to equations from the theory, are listed in the green sections.}
	\label{fig::62_nmpc_generator}
\end{figure}
The \inlinecode{}{BaseGenerator} class further loads robot specific values, such as the support polygon dimensions, the security margin, the center of mass height, and the kinematic feasibility constraints via a YAML \cite{ben2005yaml} configurations file. The support polygon therein is assumed to be rectangular, and is computed by the foot's length, and the width, which is defined in figure \ref{fig::62_support_polygon}. 
\begin{figure}[h!]
	\centering
	\includegraphics[scale=.5]{chapters/02_foundations_for_humanoid_walking/img/support_polygon.png}
	\caption{Full support polygon, and the resulting support polygon with security margin (dashed lines).}
	\label{fig::62_support_polygon}
\end{figure}
The security margin shrinks the foot's support polygon to assures that the zero moment point never comes close to the feet' edges. Other parameters that are loaded include optimization parameters, among them the weights of the objective function, the number of preview intervals, and the preview time.
\FloatBarrier
\subsection{Interpolation Class}
The \inlinecode{}{Interpolation} class takes a \inlinecode{}{BaseGenerator} object as reference, and interpolates the center of mass, as well as the feet trajectories in accordance to the current robot's state. It is, therefore, for compatibility reasons, also implemented with Eigen. Figure \ref{fig::622_interpolation} shows the most important methods of the \inlinecode{}{Interpolation} class. It sets the polynomial's coefficients for the foot interpolation, as well as the linear time-stepping matrices for the requested interpolation interval, as was explained in section \ref{sec::23_it}. The interpolation time interval, is being read in via the YAML configuration file that the \inlinecode{}{BaseGenerator} class loads.
\begin{figure}
	\centering
	\begin{tikzpicture}[node distance=2cm]
	\node (interpolation) [abstract, rectangle split, rectangle split parts=1]
	{
		\textbf{Interpolation}
	};
	\node (interpolation_methods) [comment, rectangle split, rectangle split parts=3, below=0.2cm of interpolation, text justified]
	{
		\textbf{Methods}
		\nodepart{second}\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/interpolation.cpp#L194}{InterpolateStep} \ref{eq::231_pos_poly} - \ref{eq::231_acc_poly}
		\nodepart{third}\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/interpolation.cpp#L797}{Set4thOrderCoefficients} \ref{eq::231_ai_4th}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/interpolation.cpp#L824}{Set5thOrderCoefficients} \ref{eq::231_ai_5th}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/pattern_generator/src/interpolation.cpp#L222}{InitializeLIPM} \ref{eq::223_ltss}
	};
	\end{tikzpicture}
	\caption{The \inlinecode{}{Interpolation} class takes a \inlinecode{}{BaseGenerator} object as reference, and interpolates the trajectories. Within the green section, some of the most important methods are listed with their correspondence to the theory.}
	\label{fig::622_interpolation}
\end{figure}
\FloatBarrier
\subsection{Kinematics Class}
The kinematics within this thesis are implemented with RBDL. The \inlinecode{}{Kinematics} class provides features with which it is possible to compute the forward, as well as the inverse kinematics for the control loop of figure \ref{fig::61_pg}. Methods that are used to achieve this, are listed in figure \ref{fig::623_kinematics}. As was noted in the \ref{sec::24_k} section, the inverse kinematics are based on a Levenberg-Marquardt algorithm, which may converge to local minima. The \inlinecode{}{Kinematics} class, therefore, provides a method to set the initial joint angles $\bm{q}$ via \inlinecode{}{Kinematics::SetQInit}. Just as for the previous sections, the \inlinecode{}{Kinematics} class also loads settings from a YAML configurations file, where for example the number of recalculations, or the damping parameter $\lambda$ can be set. Within the YAML file, one can further specify the location of the robot's universal robot description file, which is used by RBDL to compute the kinematics. Within the \inlinecode{}{Kinematics::Inverse} method, the center of mass orientations, and positions, are constrained in accordance to the results of the nonlinear model predictive control, so are the positions of the feet. The feet are, however, not allowed to rotate about the horizontal axes to the floor, which assures that they always stay parallel to it. The methods further constrains the robot's root frame to the initial values, which assures that the inverse kinematics does not drift to prevent hip dislocations. The \inlinecode{}{Kinematics::Forward} method then allows the user to update the current center of mass and feet positions, given the current robot's joint angles. The positions can then be obtained via the provided getter methods, which are shown in figure \ref{fig::623_kinematics}.
\begin{figure}
	\centering
	\begin{tikzpicture}[node distance=2cm]
	\node (kinematics) [abstract, rectangle split, rectangle split parts=1]
	{
		\textbf{Kinematics}
	};
	\node (kinematics_methods) [comment, rectangle split, rectangle split parts=2, below=0.2cm of kinematics, text justified]
	{
		\textbf{Methods}
		\nodepart{second}\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/kinematics/src/kinematics.cpp#L40}{SetQInit}\\\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/kinematics/src/kinematics.cpp#L47}{Forward}\\\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/kinematics/src/kinematics.cpp#L64}{Inverse}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/kinematics/include/kinematics/kinematics.h#L31}{GetComPos}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/kinematics/include/kinematics/kinematics.h#L34}{GetLFPos}\\
		\href{https://github.com/mhubii/nmpc_pattern_generator/blob/719fde0bb73925923de85cbf379c5523e075dfeb/libs/kinematics/include/kinematics/kinematics.h#L35}{GetRFPos}
	};
	\end{tikzpicture}
	\caption{The \inlinecode{}{Kinematics} class is based upon RBDL..}
	\label{fig::623_kinematics}
\end{figure}